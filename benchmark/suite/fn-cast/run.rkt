#lang racket

(require
 math/statistics
 racket/date
 "../../../src/compile.rkt")

#|
This script runs the function casting benchmark which strives to
measure the cost of space efficiency during the application of
higher-order casts
|#


#|--------------------------------------------------------------------
Configuaration variables
|#

;; Iterations = the number of times the action in question is repeated
;; in order to make it large enough to measure acurately
(define iterations 1000)

;; Runs = the number of times the test is repeated in order to understand
;; how much volitility is coming from the system it is being run on
(define runs 20)

;; casts is a list of the number of casts to test in the benchmark
(define casts (build-list 11 (lambda (i) (* 2 i))))

;; The file is hard coded for each compiler configuration because
;; it makes formatting the each new data file easier.

(define decimals 4)


#|-------------------------------------------------------------------
lightweight benchmark description

The following bit of code almost completely describes this benchmark.
In the benchmark a function is timed while a function is casted
multiple times.

This test code can be compiled with diffent compiler configurations
to test the efficiency of various representations.
|#


;; Generate the Grift Programs
(define (generate-source out iters casts)
  (pretty-print
   `(letrec ([cast-loop : (Int (Int -> Int) -> (Int -> Int))
                        (lambda ([n : Int] [g : (Int -> Int)])
                          (if (= n 0)
                              g 
                              (cast-loop (- n 1) (: g (Dyn -> Dyn)))))])
      (let ([f : (Int -> Int) (lambda ([n : Int]) n)])
        (begin
          (timer-start)
          (repeat (i 0 ,iters) (cast-loop ,casts f))
          (timer-stop)
          (timer-report))))
   #|`(let ([f : (Int -> Int) (lambda ([n : Int]) n)])
   (begin
   (timer-start)
   (repeat (i 0 ,iters) (: f (Dyn -> Dyn)))
   (timer-stop)
   (timer-report)))|#
   out 1))


#|-------------------------------------------------------------------
Directory Structure

This file always attempts to find this directory before running
any parts that will create any files.
As such it will only work from the command line.
Repls such as the repl found in emacs's racket mode cannot run
this file because they alter the 'run-file system-path making
it hard to find this directory.
|#

(define this-dir
 (path-only (path->complete-path (find-system-path 'run-file))))

;; This check is a first attempt at providing some protection from
;; this script which can create many files.
(unless (file-exists? (build-path this-dir "run.rkt"))
  (error 'run.rkt "may not work in a repl"))

;; The source directory is where the generated GTLC files will
;; be deposited
(define src-dir (build-path this-dir "src/"))
(unless (directory-exists? src-dir)
  (make-directory src-dir))

;; The temp directory is used to save copies of the C and ASM files
;; that are generated by the Grift Compiler
(define tmp-dir (build-path this-dir "tmp/"))
(unless (directory-exists? tmp-dir)
  (make-directory tmp-dir))

;; This is where the final executable benchmarks are stored
(define exe-dir (build-path this-dir "exe/"))
(unless (directory-exists? exe-dir)
  (make-directory exe-dir))

;; This is where the data is stored for each run of the benchmark
(define logs-dir (build-path this-dir "logs/"))
(unless (directory-exists? logs-dir)
  (make-directory logs-dir))

;; This is where the pdf graphs are stored
(define pdf-dir (build-path this-dir "pdfs/"))
(unless (directory-exists? pdf-dir)
  (make-directory pdf-dir))


;; The data files are "Uniquified" by the current hash of the git repo
;; and the date. The hope is that this makes keeping track of the
;; progression of the compiler and the git commit to find that commit
;; easier
(define unique-name
  (let ([date (parameterize ([date-display-format 'iso-8601])
                (date->string (current-date)))]
        [hash (parameterize ([current-output-port (open-output-string)])
                (or (and (system "git rev-parse --short HEAD")
                         (let ((s (get-output-string (current-output-port))))
                           ;; get rid of a trailing newline
                           (substring s 0 (- (string-length s) 1))))
                    "no_hash"))])
    (format "~a-~a-fn-cast" date hash)))

(define data-file (build-path logs-dir (string-append unique-name ".dat")))



(display "Generating benchmark source code\n")

;; The benchmarks are just a list of programs to generate
(define benchmarks
  (for*/list ([n (in-list casts)])
    (let* ([base (format "~a-i~a-c~a" unique-name iterations n)]
           [src  (build-path src-dir (string-append base ".grift"))]
           [port (open-output-file src #:exists 'replace)])
      (printf "\t~a\n" base)
      (generate-source port iterations n)
      (close-output-port port)
      (list base src n))))

(call-with-output-file
  (build-path this-dir "fn-cast-code-template.grift") #:exists 'replace
  (lambda (p) (generate-source p 'N-ITERATIONS 'N-CASTS)))


;; Run each benchmark for a particular compiler configuration
(define (run-series out cast-rep)
  (define (unit->micro x) (* x (expt 10 6)))
  (define (unit->pico x) (* x (expt 10 12)))
  (define spec #px"^time \\(sec\\): (\\d+.\\d+)\nUnit : \\(\\)\n$")
  (for/fold ([all-runs '()])
            ([b (in-list benchmarks)])
    (match-let ([(list base src casts) b])
      (let* ([base^ (format "~a-~a" base cast-rep)] 
             [tmpc (build-path tmp-dir (string-append base^ ".c"))]
             [tmpa (build-path tmp-dir (string-append base^ ".s"))]
             [exe  (build-path exe-dir  (string-append base^ ".out"))])
        ;; Compile the src file using the grift library
        (compile src #:output exe #:keep-c tmpc #:keep-a tmpa
                 #:cast-rep cast-rep #:cc-opt "-w" #:mem (* 4096 1000))
        ;; Give a little feedback so that running tests isn't so boring
        (printf "\t~a\n" base^)
        ;; run each test enough to establish the std-dev
        (define results
          (for/list ([run (in-range runs)])
            (let* ([result
                    ;; result is the io output of the program
                    (with-output-to-string
                      (lambda () (system (path->string exe))))]
                   ;; Regular expression for the expected output
                   ;; parse? = `(,entire-output . ,float-string) or #f
                   [parse? (regexp-match spec result)])
              (unless parse?
                (error 'benchmark/fun-app
                       "failed to parse output of ~a\n\t~a\n"
                       exe result))
              ;; parse the number
              (printf "~a ~a\n" base^ (cadr parse?))
              (cons casts (/ (unit->micro (string->number (cadr parse?))) iterations)))))
        (match-let ([(list (cons n* r*) ...) results])
          (let ([mean (mean r*)]
                [sdev (stddev r*)])
            (fprintf out "~a\t~a\t~a\n" casts mean sdev)
            (append results all-runs)))))))

(define (linear-regression x.y-ls)
  (match-define (list (cons x* y*) ...) x.y-ls)
  (define-values (μx σx μy σy r)
      (values (mean x*) (stddev x*)
              (mean y*) (stddev y*)
              (correlation x* y*)))
  (define slope (* r (/ σy σx)))
  (define y-intercept (- μy (* slope μx)))
  (list slope y-intercept r))

;; Here we gather and write the benchmark data to file
(define all-series
  (call-with-output-file data-file #:exists 'replace
    (lambda (data-out)
      (display "running benchmarks\n")
      ;; For documentation sake this bit emits a gnuplot compatable comment
      ;; that decribes the benchmark that generated the output data
      (fprintf data-out "# casted function application benchmark data\n")
      (fprintf data-out "# The current settings are\n")
      (fprintf data-out "# RUNS = ~a\n" runs)
      (fprintf data-out "# ITERATIONS = ~a\n" iterations)
      (fprintf data-out "# CASTS = ~a\n" casts)
      (fprintf data-out "# GTLC source code template:\n")
      ;; here generate source is writing to a temp buffer so that we
      ;; can comment out the code.
      (let-values ([(in out) (make-pipe)])
        (generate-source out 'ITERATIONS 'CASTS)
        ;; Sends eof
        (close-output-port out)
        (for ([line (in-lines in)])
          (display (string-append "#" line "\n") data-out)))
      (display "# data points = num-of-casts mean-time-us stddev-time\n"
               data-out)
      (for/list ([rep '(Twosomes Coercions)])
        (define s (run-series data-out rep))
        (match-define (and line (list m b r)) (linear-regression s))
        (display "\n\n" data-out)
        (printf "~a m=~a b=~a r=~a\n" rep m b r)
        (cons rep line)))))


(define (decimal->align r d)
    (define s (real->decimal-string r d))
    (unless s (error 'result-latex/decimal-aligned/s))
    (define p? (regexp-match #px"^(-?\\d+).(\\d+)$" s))
    (unless p? (error 'result-latex/decimal-aligned/p?))
    (define parts (cdr p?))
    (string-append (car parts) " & " (cadr parts)))

(define tmp-latex-file (build-path this-dir "fn-cast.tex"))
(define paper-dir  (build-path this-dir ".paper"))
(define paper-latex-file (build-path paper-dir "graphics" "fn-cast.tex"))

(call-with-output-file tmp-latex-file #:exists 'replace
  (lambda (p)
    (display
     (string-append
      "\\begin{tabular}{| c | r @{.} l | r@{.}l | r@{.}l |}\n"
      "\\hline\n"
      "Representation \n& "
      "\\multicolumn{2}{c|}{ Slope ($\\mu$s / cast) } \n&"
      "\\multicolumn{2}{c|}{ Y-Intercept ($\\mu$s)} \n& "
      "\\multicolumn{2}{c|}{ Correlation Coefficient}\\\\ \n"
      "\\hline\n")
     p)
     (for ([s all-series])
       (match-let ([(list name m b r) s])
         (fprintf p "~a & ~a & ~a & ~a\\\\ \\hline\n"
                  name
                  (decimal->align m decimals)
                  (decimal->align b decimals)
                  (decimal->align r decimals))))
     (display "\\end{tabular}\n" p)))

(when (system "which gnuplot")
  (define data (path->string data-file))
  #|
  (define make-pdf  (path->string (build-path this-dir "pdf.gnuplot")))
  (define pdf-file
    (path->string (build-path pdf-dir (string-append unique-name ".pdf"))))
  (system (format "gnuplot -e \"inFile='~a';outFile='~a'\" ~a"
                  data pdf-file make-pdf))
  |#
  (define show-plot (path->string (build-path this-dir "show.gnuplot")))
  (system (format "gnuplot -e \"inFile='~a'\" ~a" data show-plot))
  )

(when (directory-exists? paper-dir)
  (system
   (format "mv ~a ~a"
           (path->string tmp-latex-file)
           (path->string paper-latex-file))))


