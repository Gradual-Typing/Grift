#lang racket

(require
 "../../../src/compile.rkt"
 racket/date
 math/statistics)

;; This is the script for running the function application benchmark
;; which strive to measure the savings due to space efficiency during
;; function application.

;; TODO Setup command line argument that saftly cleans up tmp files,
;; build and display graphs.


#|--------------------------------------------------------------------
Configuaration variables
|#

;; Iterations = the number of times the action in question is repeated
;; in order to make it large enough to measure acurately
(define iterations 10000)

;; Runs = the number of times the test is repeated in order to understand
;; how much volitility is coming from the system it is being run on
(define runs 30)

;; casts is a list of the number of casts to test in the benchmark
(define casts (build-list 21 values))

;; The file is hard coded for each compiler configuration because
;; it makes formatting the each new data file easier.

#|-------------------------------------------------------------------
lightweight benchmark description

The following bit of code almost completely describes this benchmark.
In the benchmark a function is casted some number of times and
we time a single application of the resulting function value.
This test code can be compiled with diffent compiler configurations
to test the efficiency of applying a casted function.
|#

(define (generate-source output-port iterations casts)
  (pretty-print
   (let-values ([(annotation invocation)
                 ;; Try doing this in a typed language
                 (if (or (symbol? casts) (even? casts))
                     (values '(Int -> Int) `(cast-loop ,casts f))
                     (values '(Dyn -> Dyn)
                      `(: (cast-loop ,(sub1 casts) f) (Dyn -> Dyn))))])
     `(letrec ([cast-loop
                : (Int (Int -> Int) -> (Int -> Int))
                (lambda ([n : Int] [g : (Int -> Int)])
                  (if (= n 0)
                      g 
                      (cast-loop (- n 2) (: g (Dyn -> Dyn)))))])
        (let ([f : (Int -> Int) (lambda ([x : Int]) x)])
          (let ([f^ : ,annotation ,invocation])
            (begin
              (timer-start)
              (repeat (i 0 ,iterations) (f^ 0))
              (timer-stop)
              (timer-report))))))
   output-port 1))

#|-------------------------------------------------------------------
Directory Structure

This file always attempts to find this directory before running
any parts that will create any files.
As such it will only work from the command line.
Repls such as the repl found in emacs's racket mode cannot run
this file because they alter the 'run-file system-path making
it hard to find this directory.
|#

(define this-dir
 (path-only (path->complete-path (find-system-path 'run-file))))

;; This check is a first attempt at providing some protection from
;; this script which can create many files.
(unless (file-exists? (build-path this-dir "run.rkt"))
  (error 'run.rkt "may not work in a repl"))

;; The source directory is where the generated GTLC files will
;; be deposited
(define src-dir (build-path this-dir "src/"))
(unless (directory-exists? src-dir)
  (make-directory src-dir))

;; The temp directory is used to save copies of the C and ASM files
;; that are generated by the Schml Compiler
(define tmp-dir (build-path this-dir "tmp/"))
(unless (directory-exists? tmp-dir)
  (make-directory tmp-dir))

;; This is where the final executable benchmarks are stored
(define exe-dir (build-path this-dir "exe/"))
(unless (directory-exists? exe-dir)
  (make-directory exe-dir))

;; This is where the data is stored for each run of the benchmark
(define logs-dir (build-path this-dir "logs/"))
(unless (directory-exists? logs-dir)
  (make-directory logs-dir))

;; .paper is a symlink that I sometime put in place to automate
;; updating a paper's graphs and figures
(define paper-dir (build-path this-dir ".paper"))
(define paper-latex-plot (build-path paper-dir "graphics" "fn-app.tex"))
(define tmp-latex-plot (build-path this-dir "fn-app.tex"))


;; The data files are "Uniquified" by the current hash of the git repo
;; and the date. The hope is that this makes keeping track of the
;; progression of the compiler and the git commit to find that commit
;; easier
(define unique-name
  (let ([date (parameterize ([date-display-format 'iso-8601])
                (date->string (current-date)))]
        [hash (parameterize ([current-output-port (open-output-string)])
                (or (and (system "git rev-parse --short HEAD")
                         (let ((s (get-output-string (current-output-port))))
                           ;; get rid of a trailing newline
                           (substring s 0 (- (string-length s) 1))))
                    "no_hash"))])
    (format "~a-~a-fn-app" date hash)))

(define data-file (build-path logs-dir (string-append unique-name ".dat")))

#|-------------------------------------------------------------------
Generating the source code to benchmark

This line generates the source files and creates the list benchmarks
that records the pertinent configuration of the source files which is
the base file name, the path to the file, and the number of casts.
|#
(display "Generating benchmark source code\n")

(define benchmarks
  (for*/list ([n (in-list casts)])
    (let* ([base (format "~a-i~a-c~a" unique-name iterations n)]
           [src  (build-path src-dir (string-append base ".grift"))]
           [port (open-output-file src #:exists 'replace)])
      (printf "\t~a\n" base)
      (generate-source port iterations n)
      (close-output-port port)
      (list base src n))))

(call-with-output-file
  (build-path this-dir "fn-app.grift") #:exists 'replace
  (lambda (p) (generate-source p iterations 'N-CASTS)))

;; Run each benchmark for a particular compiler configuration
(define (run-series out cast-rep)
  (define (unit->micro x) (* x (expt 10 6)))
  (define spec #px"^time \\(sec\\): (\\d+.\\d+)\nUnit : \\(\\)\n$")
  (for* ([b (in-list benchmarks)])
    (match-let ([(list base src casts) b])
      (let* ([base^ (format "~a-~a" base cast-rep)] 
             [tmpc (build-path tmp-dir (string-append base^ ".c"))]
             [tmpa (build-path tmp-dir (string-append base^ ".s"))]
             [exe  (build-path exe-dir  (string-append base^ ".out"))])
        ;; Compile the src file using the grift library
        (compile src #:output exe #:keep-c tmpc #:keep-a tmpa
                 #:cast-rep cast-rep #:cc-opt "-w" #:mem (* 4096 100))
        ;; Give a little feedback so that running tests isn't so boring
        (printf "\t~a\n" base^)
        ;; run each test enough to establish the std-dev
        (let* ([run-results
                (for/list ([run (in-range runs)])
                  (let* ([result
                          ;; result is the io output of the program
                          (with-output-to-string
                            (lambda () (system (path->string exe))))]
                         ;; Regular expression for the expected output
                         
                   ;; parse? = `(,entire-output . ,float-string) or #f
                   [parse? (regexp-match spec result)])
                    (unless parse?
                      (error 'benchmark/fun-app
                             "failed to parse output of ~a\n\t~a\n"
                             exe result))
                    ;; parse the number
                    (unit->micro (string->number (cadr parse?)))))]
               [mean  (mean run-results)]
               [sdev  (stddev run-results)]
               [max   (apply max run-results)]
               [min   (apply min run-results)])
          (fprintf out "~a\t~a\t~a\t~a\t~a\n" casts mean sdev min max))))))

;; Here we gather and write the benchmark data to file
(call-with-output-file data-file #:exists 'replace
  (lambda (data-out)
    (display "running benchmarks\n")
    ;; For documentation sake this bit emits a gnuplot compatable comment
    ;; that decribes the benchmark that generated the output data
    (fprintf data-out "# casted function application benchmark data\n")
    (fprintf data-out "# The current settings are\n")
    (fprintf data-out "# RUNS = ~a\n" runs)
    (fprintf data-out "# ITERATIONS = ~a\n" iterations)
    (fprintf data-out "# CASTS = ~a\n" casts)
    (fprintf data-out "# GTLC source code template:\n")
    ;; here generate source is writing to a temp buffer so that we
    ;; can comment out the code.
    (let-values ([(in out) (make-pipe)])
      (generate-source out iterations 'N-CASTS)
      ;; Sends eof
      (close-output-port out)
      (for ([line (in-lines in)])
        (display (string-append "#" line "\n") data-out)))
    (display "# data points = num-of-casts mean-time-secs stddev-time\n"
             data-out)
    ;; Run the twosome compiler configuration over each benchmark
    (run-series data-out 'Twosomes)
    ;; Two newlines to start a new series
    (display "\n\n" data-out)
    ;; Run the coercion compiler configuration over each benchmark 
    (run-series data-out 'Coercions)))

(when (system "which gnuplot")
  (define data (path->string data-file))
  (define show-plot (path->string (build-path this-dir "show.gnuplot")))
  (define latex-plot (path->string (build-path this-dir "latex.gnuplot")))
  (system (format "gnuplot -e \"inFile='~a'\" ~a" data show-plot))
  (when (directory-exists? paper-dir)
    (system (format "gnuplot -e \"inFile='~a'\" ~a" data latex-plot))
    (system (format "mv ~a ~a" tmp-latex-plot paper-latex-plot))))
