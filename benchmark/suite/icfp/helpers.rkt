#lang racket
(require racket/date
         racket/runtime-path
         math/statistics
         
         "../../../src/compile.rkt"
         "../../../src/grift/syntax-to-grift0.rkt"
         "../../../src/casts/casts-to-coercions.rkt"
         "../../../src/language/forms.rkt"
         "../../../src/backend-c/code-generator.rkt")
(provide (all-defined-out))
#|-------------------------------------------------------------------
Directory Structure
|#

(define run-file-dir
  (path-only (path->complete-path (find-system-path 'run-file))))


;; The source directory is where the generated GTLC files will
;; be deposited
(define-runtime-path src-dir "src/")
(unless (directory-exists? src-dir)
  (make-directory src-dir))

;; The temp directory is used to save copies of the C and ASM files
;; that are generated by the Schml Compiler
(define-runtime-path tmp-dir "tmp/")
(unless (directory-exists? tmp-dir)
  (make-directory tmp-dir))

;; This is where the final executable benchmarks are stored
(define-runtime-path exe-dir "exe/")
(unless (directory-exists? exe-dir)
  (make-directory exe-dir))

;; This is where the data is stored for each run of the benchmark
(define-runtime-path logs-dir "logs/")
(unless (directory-exists? logs-dir)
  (make-directory logs-dir))

;; This is where the pdf graphs are stored
(define-runtime-path pdf-dir "pdfs/")
(unless (directory-exists? pdf-dir)
  (make-directory pdf-dir))

;; The data files are "Uniquified" by the current hash of the git repo
;; and the date. The hope is that this makes keeping track of the
;; progression of the compiler and the git commit to find that commit
;; easier
(define unique-name
  (let ([date (parameterize ([date-display-format 'iso-8601])
                (date->string (current-date)))]
        [hash (parameterize ([current-output-port (open-output-string)])
                (or (and (system "git rev-parse --short HEAD")
                         (let ((s (get-output-string (current-output-port))))
                           ;; get rid of a trailing newline
                           (substring s 0 (- (string-length s) 1))))
                    "no_hash"))])
    (format "~a-~a-fn-cast" date hash)))

(define data-file (build-path logs-dir (string-append unique-name ".dat")))




#| SI Unit Conversions |#
(define (unit->micro x) (* x (expt 10 6)))
(define (unit->nano x) (* x (expt 10 9)))
(define (unit->pico x) (* x (expt 10 12)))


;; Helpers for writing, compiling and running programs
(define (compile&run/iteration-time #:base-name     name
                                    #:src-file      src-file
                                    #:runs          runs
                                    #:iterations    iters
                                    #:io-sequence   [io #f]
                                    #:cast-repr     c-rep
                                    #:function-repr f-rep
                                    #:output-regexp out-rx
                                    #:unit-conversion [unit-> unit->nano]
                                    #:memory-limit  [mem (* 4096 2000)]
                                    #:mean-of-runs? [mean-of-runs? #t])

  ;; Compile the source code keeping both .c and .s files
  (define c-file   (build-path tmp-dir (string-append name ".c")))
  (define s-file   (build-path tmp-dir (string-append name ".s")))
  (define exe-file (build-path exe-dir (string-append name ".out")))

  #;(printf "compiling ~a\n" (path->string (find-relative-path run-file-dir src-file)))
  (time
   (compile src-file
           #:output exe-file
           #:keep-c c-file
           #:keep-s s-file
           #:cast c-rep
           #:cc-opts "-w -O3"
           #:mem mem))
  (define-values (run-result* iter-result*)
    (run-test-repeatedly exe-file runs iters out-rx
                         #:io-sequence io
                         #:unit-conversion unit->))
  (if mean-of-runs?
      (mean-of-runs run-result* iter-result*)
      (list run-result* iter-result*)))

(define (compile-c/run #:base-name name
                       #:src-file  src-file
                       #:runs      runs
                       #:iters     iters
                       #:io-sequence [io #f]
                       #:out-rx    out-rx
                       #:unit-conversion [unit-> unit->nano]
                       #:mean-of-runs? [mean-of-runs? #t])
  (define tmp-s (build-path tmp-dir (string-append name ".s")))
  (define exe-file (build-path exe-dir (string-append name ".out")))
  (cc/runtime (path->string tmp-s)
              (path->string src-file)
              "-w -S -O3")
  (cc/runtime (path->string exe-file)
              (path->string src-file)
              "-w -O3")
  (define-values (run-result* iter-result*)
    (run-test-repeatedly exe-file runs iters out-rx
                         #:io-sequence io
                         #:unit-conversion unit->))

  (if mean-of-runs?
      (mean-of-runs run-result* iter-result*)
      (list run-result* iter-result*)))

(define (mean-of-runs run-result* iter-result*)
  (define-values (run-mean run-sdev iter-mean iter-sdev)
    (values (mean run-result*)
            (stddev run-result*)
            (mean iter-result*)
            (stddev iter-result*)))
  (printf "\n\truns: m= ~a s= ~a\n\titer: m= ~a s= ~a\n"
          (real->decimal-string run-mean  10)
          (real->decimal-string run-sdev  10)
          (real->decimal-string iter-mean 10)
          (real->decimal-string iter-sdev 10))
  ;; Return a pair containting mean and std-deviation
  (list iter-mean iter-sdev))

;; Produces a two values a list of time per run and a list of time per iteration
;; both results are in terms of whatever unit is specified.
(define (run-test-repeatedly exe-file runs iters out-rx
                             #:io-sequence [io #f]
                             #:unit-conversion [unit->? unit->nano]
                             #:epsilon-check   [epsilon (expt 10 -6)])
  
  ;; Run the test "runs" number of times and save the results
  ;; as a list of micro-second numbers.
  (for/lists (r i)
             ([a-run (in-range 0 runs)])
    (when (= (modulo a-run 10) 0)
      (display #\. (current-error-port))
      (flush-output (current-error-port))) 
    (define result (with-output-to-string
                     (lambda ()
                       (with-input-from-string
                         (if io
                             (with-output-to-string
                               (lambda ()
                                 (for ([i (in-list io)])
                                   (display i) (newline))))
                             (format "~a" iters))
                         (lambda ()
                           (system (path->string exe-file)))))))
    ;; Regular expression for the expected output
    ;; parse? = `(,entire-output . ,float-string) or #f
    (define parse? (regexp-match out-rx result))
    (unless parse?
      (error 'benchmark/fun-app
             "failed to parse output of ~a\n\t~a\n"
             exe-file result))
    (define parsed-time? (string->number (cadr parse?)))
    (unless parsed-time?
      (error 'benchmark/fun-app
             "failed to parse numeric output of ~a\n\t~a\n"
             exe-file result))
    (unless (> parsed-time? epsilon)
      (error 'benchmark/fun-app
             "loop time not large enough for significance: ~a from ~a"
             parsed-time? exe-file))
    (define converted-time (unit->? parsed-time?))
    (values converted-time (/ converted-time iters))))


